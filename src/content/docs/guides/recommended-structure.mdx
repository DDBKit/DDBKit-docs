---
title: Recommended Structure
---

import { FileTree } from '@astrojs/starlight/components';

There are many ways to structure your projects, not
just DDBKit projects. But here's some guidance if you
need it.

Make some new targets in your Swift Package. Separate
your bot's interaction code from your "business" logic.
This will help you keep your logical code organized,
maintainable and testable.

<FileTree>
  * bot
    * Package.swift
    * Sources
      * MyBot
        * MyBot.swift
      * MyBotCore
        * MyBotCore.swift
        * Helpers.swift
        * Models
          * ...
        * Utilities
          * ...
</FileTree>

This leads into another topic. The prior guides have shown
you bots that have been mostly stateless. Whilst many bots
can be stateless, many bots will need to maintain some
state. This could be user preferences, game state, or any
other data that needs to persist between interactions.

Whilst you can store configurations on disk for
preferences etc., You will need some in-memory state.
Say for example, a game session that people in the chat
can join with a command. As DDBKit runs your commands
under separate Task contexts, we recommend using
`actor`s to provide thread-safe in-memory state.

Here's a crude example demonstrating this.

```swift
actor GameSessionManager {
	private var sessions: [String: GameSession] = [:]

	enum GameSessionError: LocalizedError {
		case sessionAlreadyExists
		case sessionNotFound
		case userAlreadyInSession

		var errorDescription: String? {
			switch self {
			case .sessionAlreadyExists:
				return "A game session already exists in this channel."
			case .sessionNotFound:
				return "No game session found in this channel."
			case .userAlreadyInSession:
				return "User is already in the game session."
			}
		}
	}

	func createSession(
		for channelID: ChannelSnowflake
	) throws -> GameSession {
		guard sessions[channelID] == nil else {
			throw GameSessionError.sessionAlreadyExists
		}
		let session = GameSession()
		sessions[channelID] = session
		return session
	}

	func getSession(
		for channelID: ChannelSnowflake
	) throws -> GameSession {
		guard let session = sessions[channelID] else {
			throw GameSessionError.sessionNotFound
		}
		return session
	}

	func endSession(
		for channelID: ChannelSnowflake
	) throws {
		if let session = sessions[channelID] {
			sessions.removeValue(forKey: channelID)
		} else {
			throw GameSessionError.sessionNotFound
		}
	}

	func joinSession(
		channelID: ChannelSnowflake,
		userID: UserSnowflake
	) -> GameSession {
		let session = try await getSession(for: channelID)
		session.addPlayer(userID: userID)
		return session
	}
}
```

That could be part of your Core target. Throwing errors in
your business logic and having a global catch as described
earlier is a good way to handle errors without explicit
handling per context.

Then in your bot target, you can create an instance to
use throughout your bot.

```swift
@main
struct MyBot: DiscordBotApp {
	init() async {
		// ...
	}

	func onBoot() async throws {
		// assign global catch for errors
		// usually by responding to the interaction or editing it with an error message
	}

	var body: [any BotScene] {
		Command("start") { i in
			// shouldn't usually fail
			guard let channelID = i.interaction.channel_id else {
				return
			}
			let session = try await gameSessionManager.createSession(for: channelID)
			try await i.respond("Game session started! Everyone join up with `/join`!")
		}
		.description("Starts a new game session in this channel.")
		.defaultPermissionRequirement([.administrator])

		Command("join") { i in
			guard let channelID = i.interaction.channel_id,
				let userID = i.interaction.user?.id
			else {
				return
			}
			let session = await gameSessionManager.joinSession(
				channelID: channelID, userID: userID)
			// do something with the session if needed
			try await i.respond("You have joined the game session!")
		}
		.description("Join the active game session in this channel.")
	}

	var bot: Bot
	var cache: Cache

	let gameSessionManager = GameSessionManager()
}
```

The best type for `GameSession` is likely a struct in this
case. Any mutation to the session data should be done via
the actor to ensure thread-safety. Returning class types
for the session representation would be less safe. Lastly,
structs are okay to return as the command lifetime is
short-lived and so the data will remain valid for the
duration of the command usually.

There are other data architectures you may require,
however that is an exercise left to the reader.
